# 1장 : 노드 시작하기

# 1.1 핵심 개념 이해하기

## Node.js

- Chrome V8 Javascript 엔진으로 빌드된 자바스크립트 런타임

## 1.1.1 서버

- 서버 : 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램
- 클라이언트 : 요청을 보내는 주체로, 브라우저 또는 데스크톱 프로그램, 모바일 앱, 다른 서버에 요청을 보내는 서버 등
- 서버 또한 다른 서버에 요청을 보낼 수 있는데, 이때는 요청을 보낸 서버가 클라이언트 역할
- 서버는 응답으로부터 항상 Yes를 해야 하는 것은 아니고, No를 할 수도 있음
- 노드는 자바스크립트 프로그램이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있음

## 1.1.2 자바스크립트 런타임

- **런타임** : 특정 언어로 만든 프로그램들을 실행할 수 있는 환경
    - 노드는 자바스크립트 프로그램을 컴퓨터에서 실행 → 노드는 자바스크립트 실행기
- 기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행 가능했음
- 브라우저는 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있었음
- 브라우저 외의 환경에서 자바스크립트를 실행하기 위한 여러 시도가 있었으나 자바스크립트의 실행 속도 문제로 인해 큰 호응을 얻지 못함
- 2008년 구글이 V8 엔진을 사용해 크롬을 출시
    - V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐고, 오픈 소스로 코드를 공개
    - 속도 문제가 해결되자 라이언 달(Ryan Dahl)은 2009년 V8 엔진 기반의 노드 프로젝트 시작
- 노드는 V8과 더불어 libuv라는 라이브러리를 사용
    - V8과 libuv는 C와 C++로 구현되어 있음
    - 자바스크립트로 코딩하면 노드가 자동으로 V8과 libuv에 연결
    - libuv 라이브러리는 이벤트 기반, 논블로킹 I/O 모델을 구현

## 1.1.3 이벤트 기반

- **이벤트 기반**(event-driven) : 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식
- 클릭, 네트워크 요청 등
- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해둬야 함
    
    → 이벤트 리스너(event listener)에 콜백(callback) 함수를 등록한다고 표현
    
    - ex. 클릭 이벤트 리스너에 경고창을 띄우는 콜백 함수를 등록
- 노드도 이벤트 기반 방식으로 동작
- **이벤트 루프**(event loop) : 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지 결정하는 역할, 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부름
    - 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행
    - 함수 호출 부분을 발견했다면 호출한 함수를 호출 스택(call stack)에 넣음
    
    ```jsx
    function first() {
    		second();
    		console.log('첫 번째');
    }
    function second() {
    		third();
    		console.log('두 번째');
    }
    function third() {
    		console.log('세 번째');
    }
    first();
    ```
    
    - first - second - third 순으로 함수가 호출되지만 실행은 반대 순서로 이루어짐

    
    - **콘텍스트**(context) : 함수 호출 시 생성되는 환경, 그림에서는 anonymous 함수를 말함
    - 자바스크립트 코드는 실행 시 기본적으로 전역 콘텍스트 안에서 돌아감
    - 함수는 실행되는 동안 호출 스택에 머물러 있다가 실행이 완료되면 호출 스택에서 지워짐
    - third - second - first - anonymous 순으로 지워지고, anonymous 콘텍스트까지 실행이 완료되면 호출 스택은 비어 있게 됨
    
    ```jsx
    function run() {
    		console.log('3초 후 실행');
    }
    console.log('시작');
    setTimeout(run, 3000);
    
    console.log('끝');
    /* <콘솔>
    		시작
    		끝
    		3초 후 실행 */
    ```
    
    - setTumeout 함수를 이용하여 특정 밀리초 이후에 코드 실행
    - 전역 콘텍스트인 anonymous가 호출 스택에 들어간 뒤 setTimeout이 호출 스택에 들어가므로 실행 순서는 반대가 됨
    - setTimeout이 실행되면 타이머와 함께 run 콜백 함수를 백그라운드로 보내고, setTimeout은 호출 스택에서 빠짐
    - 백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보냄
    - 이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 하나씩 함수를 가져와 호출 스택에 넣고 실행
    - 호출 스택에 함수가 많이 들어있는 경우 3초가 지난 후에도 run 함수가 실행되지 않을 수도 있음(이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 run 함수를 호출 스택으로 가져오기 때문) → setTimeout의 시간이 정확하지 않을 수도 있는 이유
- **백그라운드**(background) : setTimeout같은 타이머나 이벤트 리스너들이 대기하는 곳
    - 자바 스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 무방하며, 여러 작업이 동시에 실행될 수 있음
- **태스크 큐**(task queue) : 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보냄
    - 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 함
    - 콜백들은 보통 완료된 순서대로 줄을 서 있지만, 특정한 경우 순서가 바뀌기도 함

## 1.1.4 논블로킹 I/O

- 작업에는 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업 두 종류가 있는데, 자바스크립트 코드는 동시에 실행될 수 없음
- 자바스크립트 상에서 돌아가는 것이 아닌 I/O 작업은 동시에 처리될 수 있음
- I/O : 입력(Input)/출력(Output)을 의미
    - 파일 시스템 접근(파일 읽기 및 쓰기, 폴더 만들기 등), 네트워크를 통한 요청 같은 작업 등
- I/O와 같은 작업을 할 때 노드는 논블로킹 방식으로 처리하는 방법 제공
- **논블로킹**(non-blocking) : 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것
- **블로킹**(blocking) : 이전 작업이 끝나야만 다음 작업을 수행하는 것
- 블로킹 방식보다 논블로킹 방식이 같은 작업을 더 짧은 시간에 처리하지만 작업들이 모두 동시에 처리될 수 있는 작업이라는 전제가 있음
- 노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리 → 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있음
- 블로킹 방식의 코드

```jsx
function longRunningTask() {
		// 오래 걸리는 작업
		console.log('작업 끝');
}

console.log('시작');
longRunningTask();
console.log('다음 작업');

/* <콘솔>
		시작
		작업 끝
		다음 작업
		/*
```

- 논블로킹 방식의 코드(setTimeout 사용)

```jsx
function longRunningTask() {
		// 오래 걸리는 작업
		console.log('작업 끝');
}

console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');

/* <콘솔>
		시작
		다음 작업
		작업 끝 /*
```

setTimeout의 콜백 함수인 longRunningTask가 태스크 큐로 보내지므로 순서대로 실행되지 않음

- 자바스크립트 코드는 동시에 실행되지 않기 때문에 논블로킹 방식으로 코드를 작성하더라도 전체 소요 시간이 짧아지지는 않고, 실행 순서를 바꿔줌으로써 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있음
- 논블로킹과 동시는 같은 의미가 아님(동시성은 동시 처리가 가능한 작업을 논블로킹 처리해야 얻을 수 있는 것)

## 1.1.5 싱글 스레드

- **싱글 스레드** : 스레드가 하나뿐이라는 것을 의미
- **프로세스** : 운영체제에서 할당하는 작업의 단위
    - 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스로, 프로세스 간에는 메모리 등의 자원을 공유하지 않음
- **스레드** : 프로세스 내에서 실행되는 흐름의 단위
    - 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있음
    - 스레드들은 부모 프로세스의 자원을 공유(같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있음)
- 노드는 엄밀히 말하면 싱글 스레드로 동작하지는 않음
    - 노드를 실행하면 프로세스가 먼저 하나 생성되고, 그 프로세스에서 스레드들을 생성하는데 내부적으로 여러 개 생성
    - 그 중에서 직접 제어할 수 있는 스레드는 하나뿐 → 노드가 싱글 스레드라고 여겨지는 이유
- 요청이 많이 들어오면 한 번에 하나씩 요청을 처리하고, 블로킹이 발생할 것 같은 경우에는 논블로킹 방식으로 대기 시간을 최대한 줄임(싱글 스레드, 논블로킹 모델)

| 멀티 스레딩 | 멀티 프로세싱 |
| --- | --- |
| 하나의 프로세스 안에서 여러 개의 스레드 사용 | 여러 개의 프로세스 사용 |
| CPU 작업이 많이 사용될 때 사용 | I/O 요청이 많을 때 사용 |
| 프로그래밍이 어려움 | 비교적 쉬움 |

# 1.2 서버로서의 노드

- 노드는 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합
    - 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문
    - 실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용
- 노드 12버전에서 워커 스레드 기능의 안정화로 멀티 스레드 작업을 할 수 있게 되었지만, 멀티 스레드 프로그래밍을 하는 것은 싱글 스레드에 비해 난이도가 높을 뿐 아니라 C, C++, Rust, Go와 같은 언어에 비해 속도가 많이 느림 → 멀티 스레드 기능이 있다고 하더라도 이미지나 비디오 처리, 대규모 데이터 처리와 같이 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않음
- 싱글 스레드 방식으로 서버를 운영할 때는 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 함
    - 에러를 제대로 처리하지 못하면 하나뿐인 스레드가 죽게 되어 서버 전체가 멈추기 때문
- 노드는 웹 서버가 내장되어 있어 입문자가 쉽게 접근할 수 있지만 나중에 서버 규모가 커지면 결국 nginx 등의 웹 서버를 노드 서버와 연결해야 하긴 함
- 웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있음 → 개발 생산성을 획기적으로 높였고, 생산성이 중요한 기업이 노드를 채택하는 이유가 됨
- 노드는 생산성은 매우 좋지만, Go처럼 비동기에 강점을 보이는 언어나 nginx처럼 정적 파일 제공, 로드 밸런싱에 특화된 웹 서버에 비해서는 속도가 느림 → 극단적인 성능이 필요하지 않다면 이러한 단점은 노드의 생산성으로 어느 정도 극복할 수 있음
- 요즘은 XML 대신 JSON을 사용해서 데이터를 주고받는데, JSON이 자바스크립트 형식이므로 노드에서 쉽게 처리할 수 있음

| 장점 | 단점 |
| --- | --- |
| 멀티 스레드 방식에 비해 적은 컴퓨터 자원 사용 | 기본적으로 싱글 스레드라서 CPU 코어를 하나만 사용 |
| I/O 작업이 많은 서버로 적합 | CPU 작업이 많은 서버로는 부적합 |
| 멀티 스레드 방식보다 쉬움 | 하나뿐인 스레드가 멈추지 않도록 관리 필요 |
| 웹 서버가 내장되어 있음 | 서버 규모가 커졌을 때 서버를 관리하기 어려움 |
| 자바스크립트를 사용 | 어중간한 성능 |
| JSON 형식과 쉽게 호환됨 |  |
- 미국항공우주국(NASA), 에어비엔비, 우버, 넷플릭스, 링크드인 등 세계 유수의 기관과 기업에서 노드를 사용하고 있음
- 페이팔, 월마트, 이베이와 같이 결제 시스템을 사용하는 대기업들도 노드로 서비스를 운영
- 국내에서도 네이버, 카카오, 위메프, 야놀자 같은 기업들이 노드를 사용

# 1.3 서버 외의 노드

- 처음에는 노드를 대부분 서버로 사용했지만, 노드는 자바스크립트 런타임이므로 용도가 서버로만 국한되지 않음
    - 사용 범위가 점점 늘어나서 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용되기 시작
- 노드 기반으로 돌아가는 대표적인 웹 프레임워크
    - 앵귤러(Angular) : 구글 진영에서 프론트엔드 앱을 만들 때 주로 사용
    - 리액트(React) : 페이스북 진영에서 주로 사용
    - 모바일 개발 도구로는 리액트 네이티브(React Native)를 많이 사용 : 페이스북, 인스타그램, 핀터레스트, 월마트, 테슬라 등
    - 데스크톱 개발 도구로는 일렉트론(Electron)이 대표적 : Atom, Slack, Discord, Visual Studio Code 등
    - 뷰(Vue)